<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cards ‚Äî Static MVP</title>
    <style>
      :root { color-scheme: dark; font-family: Inter, system-ui, Arial, sans-serif; }
      body { margin: 0; background: #0b0f1a; color: #e8ecf3; overflow: hidden; }
      .app {
        max-width: 1100px;
        margin: 0 auto;
        min-height: 100vh;
        padding: 6px;
        box-sizing: border-box;
        display: grid;
        grid-template-rows: auto auto;
        align-content: start;
        gap: 6px;
        overflow: hidden;
      }
      section { margin-top: 0; background: #141c2d; border: 1px solid #25304a; border-radius: 12px; padding: 10px; min-height: 0; }
      h1 { margin: 0; font-size: 1.2rem; }
      h2 { margin: 0 0 6px; font-size: 1rem; }
      p { margin: 4px 0; }
      .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      input, button { border-radius: 10px; border: 1px solid #314567; background: #0d1320; color: #e8ecf3; padding: 10px 12px; }
      button { cursor: pointer; background: #233050; font-weight: 600; }
      button:hover { background: #2d4169; }
      .error { margin-top: 12px; background: #381a1a; border: 1px solid #6f2d2d; color: #ffd4d4; padding: 10px; border-radius: 8px; }
      .table-shell { background: radial-gradient(circle at center, #1f6b3f 0%, #124a2c 60%, #0c351f 100%); border: 2px solid #8a6a2f; border-radius: 22px; padding: 14px; }
      .board { display: flex; gap: 6px; flex-wrap: wrap; min-height: 34px; align-items: center; }
      .card-pill { display:inline-flex; align-items:center; justify-content:center; min-width:38px; height:46px; border-radius:8px; border:1px solid #5a6b8f; background:#f5f7ff; color:#0a0f1d; font-weight:800; }
      .card-pill.red { color:#b3132c; }
      .card-pill.deal { animation: dealIn .45s ease; transform-origin: center; }
      @keyframes dealIn {
        0% { transform: translateY(-14px) scale(.78); opacity: 0; }
        100% { transform: translateY(0) scale(1); opacity: 1; }
      }

      .table-ring {
        position: relative;
        margin-top: 6px;
        height: clamp(230px, 40vh, 440px);
        border-radius: 24px;
        border: 1px solid #2d3a59;
        background: radial-gradient(circle at center, rgba(31,107,63,.18), rgba(10,20,30,.08));
        overflow: visible;
      }
      .table-ring::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: min(76%, 820px);
        aspect-ratio: 2.4 / 1;
        border-radius: 999px;
        border: 7px solid #5c3010;
        outline: 3px solid #7a4520;
        background: radial-gradient(ellipse at 50% 40%, #22853a 0%, #175a27 65%, #0f4019 100%);
        box-shadow: inset 0 0 20px rgba(0,0,0,.28), 0 6px 24px rgba(0,0,0,.5);
        z-index: 0;
      }
      .ring-center {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: min(64%, 400px);
        z-index: 2;
        text-align: center;
      }
      .ring-center .table-shell { padding: 8px 10px; }
      .ring-center .chips { justify-content: center; flex-wrap: wrap; gap: 4px; margin-bottom: 5px; }
      .ring-center .board { justify-content: center; }
      .ring-center .wait-msg { color: #6a8fa8; font-size: .82rem; padding: 4px 0; }
      .start-round-btn {
        width: 100%; padding: 11px 0; font-size: 1rem; font-weight: 700;
        background: #1a3a24; border: 1.5px solid #2e6640; color: #6de87a;
        border-radius: 14px; cursor: pointer; letter-spacing: .02em;
        box-shadow: 0 0 16px rgba(80,200,100,.18);
        transition: background .18s, box-shadow .18s;
      }
      .start-round-btn:hover { background: #1f4a2c; box-shadow: 0 0 24px rgba(80,200,100,.32); }
      /* Seat cards ‚Äî compact, absolutely positioned around the oval */
      .seat { background: #0d1320; border: 1.5px solid #2a3a5a; border-radius: 10px; padding: 6px 7px; position: absolute; width: 92px; font-size: .72rem; transition: border-color .2s ease, box-shadow .2s ease, opacity .25s ease, filter .25s ease; box-sizing: border-box; }
.seat-head { display:flex; align-items:center; gap:3px; flex-wrap:wrap; margin-bottom:3px; }
.seat-head strong { font-size:.74rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:56px; }
.seat-meta { display:flex; gap:5px; flex-wrap:wrap; color:#c7d3ea; font-size:.66rem; margin-bottom:3px; }
.seat-cards { display:flex; gap:3px; align-items:center; }
      .seat.folded { opacity: .38; filter: grayscale(.6); }
      /* 3 top, 1 right, 3 bottom, 1 left ‚Äî seats straddle the oval rail */
      .seat.pos-0 { top: 16%; left: 20%;  transform: translateX(-50%); }          /* top-left */
      .seat.pos-1 { top: 13%; left: 50%;  transform: translateX(-50%); }          /* top-center */
      .seat.pos-2 { top: 16%; left: 80%;  transform: translateX(-50%); }          /* top-right */
      .seat.pos-3 { top: 50%; left: 96%;  transform: translate(-100%, -50%); }    /* right */
      .seat.pos-4 { top: 82%; left: 80%;  transform: translateX(-50%); }          /* bottom-right */
      .seat.pos-5 { top: 85%; left: 50%;  transform: translateX(-50%); }          /* bottom-center */
      .seat.pos-6 { top: 82%; left: 20%;  transform: translateX(-50%); }          /* bottom-left */
      .seat.pos-7 { top: 50%; left: 4%;   transform: translateY(-50%); }          /* left */
      .marker { display:inline-block; font-size:.75rem; padding:2px 6px; border-radius:999px; margin-left:6px; border:1px solid #4c5f86; background:#15233c; }
      .marker.dealer { background:#3a2c12; border-color:#caa252; color:#ffd87a; }
      .marker.sb { background:#1a2b48; border-color:#5a86d1; color:#b8d5ff; }
      .marker.bb { background:#3a1a44; border-color:#ae68d3; color:#efc7ff; }
      .chip-move { position:absolute; z-index:4; background:#2a3552; border:1px solid #6f88bf; border-radius:999px; padding:4px 8px; font-size:.8rem; animation: chipFly 1s ease forwards; }
      @keyframes chipFly {
        0% { transform: translate(-50%, -50%) scale(.5); opacity: 0; left: 50%; top: 50%; }
        25% { opacity: 1; }
        100% { opacity: 0; }
      }
      .chip-move.pos-0 { left:50%; top:40px; }
      .chip-move.pos-1 { right:30px; top:95px; }
      .chip-move.pos-2 { right:24px; top:50%; }
      .chip-move.pos-3 { right:30px; bottom:95px; }
      .chip-move.pos-4 { left:50%; bottom:40px; }
      .chip-move.pos-5 { left:30px; bottom:95px; }
      .chip-move.pos-6 { left:24px; top:50%; }
      .chip-move.pos-7 { left:30px; top:95px; }
      .seat.turn {
        border-color: #f0c040;
        box-shadow: 0 0 14px rgba(240,192,64,0.6), 0 0 0 2px rgba(240,192,64,0.2) inset;
        animation: breatheGlow 1.6s ease-in-out infinite;
      }
      .seat.just-turned { animation: turnPop .45s ease, breatheGlow 1.6s ease-in-out .45s infinite; }
      @keyframes turnPop {
        0% { transform: scale(.92); }
        100% { transform: scale(1); }
      }
      @keyframes breatheGlow {
        0%, 100% { box-shadow: 0 0 0 2px rgba(255,216,77,0.2) inset, 0 0 10px rgba(255,216,77,0.25); }
        50% { box-shadow: 0 0 0 2px rgba(255,216,77,0.45) inset, 0 0 24px rgba(255,216,77,0.65); }
      }
      .turn-badge { color: #ffdf66; font-weight: 700; margin-left: 8px; }
      .muted { color: #a6b0c2; }
      button:disabled { opacity: 0.45; cursor: not-allowed; }
      .main-table { grid-row: 1; display: flex; flex-direction: column; min-height: 0; }
      .bottom-actions { grid-row: 2; }

      /* ‚îÄ‚îÄ Floating join button ‚îÄ‚îÄ */
      .join-float { position: fixed; top: 8px; right: 8px; z-index: 200; }
      .join-toggle {
        background: #1a3a24; border: 1px solid #2e6640; color: #6de87a;
        border-radius: 20px; padding: 7px 14px; font-size: .8rem; font-weight: 700;
        cursor: pointer; white-space: nowrap; box-shadow: 0 2px 8px rgba(0,0,0,.4);
      }
      .join-toggle:hover { background: #1f4a2c; }
      .join-toggle.is-joined { background: #12233a; border-color: #2d5080; color: #7ac2e8; }
      .join-drop {
        position: absolute; top: calc(100% + 6px); right: 0;
        background: #141c2d; border: 1px solid #25304a; border-radius: 12px;
        padding: 10px; min-width: 264px;
        box-shadow: 0 8px 28px rgba(0,0,0,.55); z-index: 201;
      }
      .join-drop .row { gap: 6px; }
      .join-drop input { flex: 1; min-width: 0; }
      .join-drop .row-2 { display: flex; gap: 6px; margin-top: 6px; }
      .join-drop .row-2 button { flex: 1; }
      .join-whoami { color: #a6b0c2; font-size: .72rem; margin: 6px 0 0; }
      .action-bar { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
      .action-row { display:grid; gap:6px; }
      .action-row.top { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .action-row.bottom { grid-template-columns: 2fr 1fr 1fr; }
      .action-row button, .action-row input { width: 100%; box-sizing: border-box; }
      .action-note { font-weight:700; color:#9fc1ff; }
      .chips { display:inline-flex; gap:8px; align-items:center; }
      .chip { background:#1b2740; border:1px solid #3d547f; border-radius:999px; padding:4px 10px; font-size:0.9rem; }
      @media (max-width: 520px) {
        .app { padding: 4px; gap: 4px; }
        h2 { font-size: .85rem; margin-bottom: 3px; }
        section { padding: 5px; border-radius: 8px; }
        .row { gap: 4px; }
        input, button { box-sizing: border-box; padding: 6px 7px; font-size: .8rem; }
        .join-drop { min-width: 220px; }
        .join-drop input, .join-drop button { padding: 6px 8px; font-size: .78rem; }
        .chips { gap: 3px; }
        .chip { padding: 2px 6px; font-size: .68rem; }
        .card-pill { min-width: 28px; height: 34px; font-size: .82rem; }
        .action-bar { background: #10192a; padding: 4px; border:1px solid #2d3a59; border-radius: 8px; }
        .action-row { gap:4px; }
        .action-row.bottom { grid-template-columns: 2fr 1fr 1fr; }
        .table-ring { height: clamp(200px, 38vh, 340px); }
        .ring-center { width: min(68%, 340px); }
        .ring-center .board .card-pill { min-width: 22px; height: 28px; font-size: .74rem; }
        .seat { width: 76px; font-size: .61rem; padding: 4px 5px; }
        .seat-head strong { font-size: .63rem; max-width: 42px; }
        .seat-meta { font-size: .57rem; gap: 3px; }
        .seat .card-pill { min-width: 20px; height: 26px; font-size: .7rem; }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <!-- Table Seats ‚Äî fills all vertical space, game info rendered inside oval by JS -->
      <section class="main-table">
        <div class="table-ring">
          <div class="ring-center" id="ringCenter">
            <!-- populated by render() -->
          </div>
          <div id="seats"></div>
        </div>
        <div class="muted" id="log" style="font-size:.75rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; padding: 2px 4px;">No actions yet.</div>
      </section>

      <!-- Your Hand & Actions -->
      <section class="bottom-actions">
        <div id="error" class="error" style="display:none"></div>
        <h2>Your Hand <span class="muted" id="actionState" style="font-weight:400; font-size:.82rem">‚Äî waiting</span></h2>
        <div class="board" id="myHand"></div>
        <div class="row" style="margin-top:4px">
          <span id="toCall">To call: 0</span>
          <span id="myStack">Stack: -</span>
        </div>
        <div class="action-bar">
          <div class="action-row top">
            <button id="foldBtn">‚ùå Fold</button>
            <button id="checkBtn">‚úÖ Check</button>
            <button id="callBtn">üìû Call</button>
          </div>
          <div class="action-row bottom">
            <input id="raiseTo" type="number" placeholder="Raise to" />
            <button id="raiseBtn">‚¨ÜÔ∏è Raise</button>
            <button id="allinBtn">üî• All-in</button>
          </div>
        </div>
      </section>
    </main>

    <!-- Floating join panel -->
    <div class="join-float" id="joinFloat">
      <button class="join-toggle" id="joinToggle">Ôºã Join</button>
      <div class="join-drop" id="joinDrop" hidden>
        <div class="row">
          <input id="username" placeholder="username" maxlength="20" />
          <button id="joinBtn">Join</button>
          <button id="leaveBtn">Leave</button>
        </div>
        <div class="row-2">
          <button id="refreshBtn">Refresh</button>
          <button id="clearLobbyBtn">Clear Lobby</button>
        </div>
        <p class="join-whoami" id="whoami"></p>
      </div>
    </div>

    <script type="module">
      import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
      import PokerHand from 'https://esm.sh/poker-hand-evaluator@1.0.1'

      const SUPABASE_URL = 'https://oiltjegxfwjdvuzbsyfv.supabase.co'
      const SUPABASE_ANON_KEY = 'sb_publishable_7rNCoUWbz3FnDY4VdIvCbg_9R-LuirL'
      const SB = 1
      const BB = 2

      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      const sessionKey = 'cards_session_id'
      let sessionId = localStorage.getItem(sessionKey)
      if (!sessionId) {
        sessionId = crypto.randomUUID()
        localStorage.setItem(sessionKey, sessionId)
      }

      let currentPlayers = []
      let currentGame = {}
      let currentHand = {}
      let lastActingSessionId = null

      const $ = (id) => document.getElementById(id)
      const showError = (msg) => {
        const el = $('error')
        el.style.display = msg ? 'block' : 'none'
        el.textContent = msg || ''
      }

      const shuffle = (arr) => {
        const a = [...arr]
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]
        }
        return a
      }
      const mkDeck = () => shuffle('23456789TJQKA'.split('').flatMap(r => 'CDHS'.split('').map(s => r+s)))
      const SUIT_EMOJI = { C: '‚ô£Ô∏è', D: '‚ô¶Ô∏è', H: '‚ô•Ô∏è', S: '‚ô†Ô∏è' }
      const prettyCard = (c) => {
        if (!c || typeof c !== 'string' || c.length < 2) return c || '-'
        const rank = c[0]
        const suit = c[1].toUpperCase()
        return `${rank}${SUIT_EMOJI[suit] || suit}`
      }
      const prettyCards = (cards) => (cards || []).map(prettyCard).join(' ')
      const cardHtml = (c) => {
        const p = prettyCard(c)
        const isRed = p.includes('‚ô¶Ô∏è') || p.includes('‚ô•Ô∏è')
        return `<span class="card-pill ${isRed ? 'red' : ''}">${p}</span>`
      }
      const cardsHtml = (cards, faceDown = false, count = 2, dealing = false) => {
        if (faceDown) return Array.from({ length: count }).map(() => `<span class="card-pill ${dealing ? 'deal' : ''}">üÇ†</span>`).join(' ')
        if (!cards || !cards.length) return '<span class="muted">-</span>'
        const dealClass = dealing ? ' deal' : ''
        return cards.map(c => cardHtml(c).replace('card-pill', `card-pill${dealClass}`)).join(' ')
      }
      const boardSlotsHtml = (cards = [], dealing = false) => {
        const shown = cards.map(c => cardHtml(c).replace('card-pill', `card-pill${dealing ? ' deal' : ''}`))
        const hidden = Array.from({ length: Math.max(0, 5 - cards.length) }).map(() => `<span class="card-pill">üÇ†</span>`)
        return [...shown, ...hidden].join(' ')
      }

      const nextSeat = (from, seats) => {
        const sorted = [...seats].sort((a,b)=>a-b)
        for (const s of sorted) if (s > from) return s
        return sorted[0]
      }

      const combos = (arr, k) => {
        const out = []
        const pick = (start, acc) => {
          if (acc.length === k) return out.push(acc)
          for (let i = start; i < arr.length; i++) pick(i + 1, [...acc, arr[i]])
        }
        pick(0, [])
        return out
      }

      const bestScore7 = (cards7) => {
        let best = Infinity
        for (const c of combos(cards7, 5)) {
          const h = new PokerHand(c.join(' '))
          best = Math.min(best, h.getScore())
        }
        return best
      }

      const getMe = () => currentPlayers.find(p => p.session_id === sessionId)
      const getMyHandPlayer = () => currentHand.playersBySession?.[sessionId]

      async function saveHand(state) {
        const { error } = await supabase.from('game_state').update({
          phase: state.street || 'waiting',
          current_turn_session_id: state.actingSessionId || null,
          pot: state.pot || 0,
          hand_state: state,
          updated_at: new Date().toISOString(),
          last_action_at: new Date().toISOString(),
        }).eq('id', 1)
        if (error) throw error
      }

      function render() {
        const me = getMe()
        const hand = currentHand || {}
        const meHp = getMyHandPlayer()

        $('whoami').textContent = me ? `Joined as ${me.username} (seat ${me.seat_no})` : `Not joined (session ${sessionId.slice(0,8)}...)`
        const jt = document.getElementById('joinToggle')
        if (jt) {
          jt.textContent = me ? `${me.username} ‚ñæ` : 'Ôºã Join'
          jt.className = me ? 'join-toggle is-joined' : 'join-toggle'
        }
        const street = hand.street || 'waiting'
        const pot = hand.pot || currentGame.pot || 0
        const dealingNow = hand.startedAt && (Date.now() - new Date(hand.startedAt).getTime() < 2200)
        const seatedCount = currentPlayers.filter(p => p.seat_no != null).length
        const isWaiting = street === 'waiting' || !hand.street

        // ‚îÄ‚îÄ Render ring-center dynamically ‚îÄ‚îÄ
        const rc = $('ringCenter')
        if (isWaiting && seatedCount >= 2) {
          rc.innerHTML = `<button class="start-round-btn" id="startRoundBtn">‚ñ∂ Start Round</button>`
          $('startRoundBtn').onclick = startHand
        } else if (isWaiting) {
          rc.innerHTML = `<div class="wait-msg">Waiting for players‚Ä¶<br><span style="font-size:.7rem;opacity:.6">${seatedCount}/2 joined</span></div>`
        } else {
          rc.innerHTML = `<div class="table-shell">
            <div class="chips">
              ${pot > 0 ? `<span class="chip">Pot: ${pot}</span>` : ''}
              <span class="chip">${street}</span>
              ${hand.currentBet ? `<span class="chip">Bet: ${hand.currentBet}</span>` : ''}
            </div>
            <div class="board" style="justify-content:center">${boardSlotsHtml(hand.boardCards || [], dealingNow)}</div>
          </div>`
        }
        $('myHand').innerHTML = meHp?.holeCards?.length ? cardsHtml(meHp.holeCards, false, 2, dealingNow) : '<span class="muted">No cards (join + start hand)</span>'

        const toCall = meHp ? Math.max(0, (hand.currentBet || 0) - (meHp.currentBet || 0)) : 0
        $('toCall').textContent = `To call: ${toCall}`
        $('myStack').textContent = `Stack: ${meHp?.stack ?? me?.stack ?? '-'}`

        const myTurn = hand.actingSessionId && hand.actingSessionId === sessionId
        $('actionState').textContent = myTurn ? '‚Äî üü° Your turn' : '‚Äî ‚è≥ waiting'
        $('foldBtn').disabled = !myTurn
        $('checkBtn').disabled = !myTurn || toCall > 0
        $('callBtn').disabled = !myTurn || toCall === 0
        $('raiseBtn').disabled = !myTurn
        $('allinBtn').disabled = !myTurn

        const ringPlayers = currentPlayers
          .filter(p => p.seat_no != null)
          .sort((a,b)=>a.seat_no-b.seat_no)

        const seatToIdx = new Map(ringPlayers.map((p, i) => [p.seat_no, i % 8]))
        $('seats').innerHTML = ringPlayers
          .map((p, idx) => {
            const hp = hand.playersBySession?.[p.session_id]
            const isTurn = hand.actingSessionId && hand.actingSessionId === p.session_id
            const justTurned = isTurn && lastActingSessionId && lastActingSessionId !== hand.actingSessionId
            const isFolded = !!hp?.folded
            const holeHtml = (p.session_id === sessionId || hand.street === 'waiting')
              ? cardsHtml(hp?.holeCards || [], false, 2, dealingNow)
              : cardsHtml([], true, 2, dealingNow)
            const dealerTag = hand.dealerSeat === p.seat_no ? '<span class="marker dealer">D</span>' : ''
            const sbTag = hand.sbSeat === p.seat_no ? '<span class="marker sb">SB</span>' : ''
            const bbTag = hand.bbSeat === p.seat_no ? '<span class="marker bb">BB</span>' : ''
            return `<div class="seat pos-${idx % 8} ${isTurn ? 'turn' : ''} ${justTurned ? 'just-turned' : ''} ${isFolded ? 'folded' : ''}">
              <div class="seat-head"><strong>${p.username}</strong><span class="muted">S${p.seat_no}</span>${dealerTag}${sbTag}${bbTag}${isTurn ? '<span class="turn-badge">‚óÄ TURN</span>' : ''}</div>
              <div class="seat-meta"><span>Stack ${hp?.stack ?? p.stack}</span><span>Bet ${hp?.currentBet ?? 0}</span><span>Last ${hp?.lastAction || '-'}</span></div>
              <div class="seat-cards">${holeHtml}</div>
            </div>`
          }).join('')

        const move = hand.lastChipMove
        if (move && Date.now() - (move.ts || 0) < 1200) {
          const idx = seatToIdx.get(move.seat)
          if (idx !== undefined) {
            $('seats').innerHTML += `<div class="chip-move pos-${idx}">ü™ô ${move.label}: +${move.amount}</div>`
          }
        }

        lastActingSessionId = hand.actingSessionId || null

        const log = hand.actionLog || []
        $('log').textContent = log.length ? `Recent: ${log.slice(-1)[0]}` : 'No actions yet.'
      }

      async function refresh() {
        showError('')
        const [pRes, gRes] = await Promise.all([
          supabase.from('lobby_players').select('*').order('seat_no', { ascending: true }),
          supabase.from('game_state').select('*').eq('id', 1).single(),
        ])
        if (pRes.error) return showError(pRes.error.message)
        if (gRes.error) return showError(gRes.error.message)

        currentPlayers = pRes.data || []
        currentGame = gRes.data || {}
        currentHand = currentGame.hand_state || {}
        render()
      }

      async function join() {
        const username = $('username').value.trim()
        if (!username) return showError('Username required')
        const { data } = await supabase.from('lobby_players').select('seat_no')
        const used = new Set((data||[]).map(p=>p.seat_no).filter(Boolean))
        let seat = null
        for (let i=1;i<=8;i++) if (!used.has(i)) { seat = i; break }
        if (!seat) return showError('Lobby full')

        const { error } = await supabase.from('lobby_players').upsert({
          session_id: sessionId,
          username,
          seat_no: seat,
          heartbeat_at: new Date().toISOString(),
        }, { onConflict: 'session_id' })
        if (error) return showError(error.message)
        document.getElementById('joinDrop').hidden = true
        refresh()
      }

      async function leave() {
        await supabase.from('lobby_players').delete().eq('session_id', sessionId)
        refresh()
      }

      async function startHand() {
        await refresh()
        const seated = currentPlayers.filter(p => p.seat_no != null).sort((a,b)=>a.seat_no-b.seat_no)
        if (seated.length < 2) return showError('Need at least 2 players')

        const prevDealer = currentGame.dealer_seat || seated[0].seat_no
        const seats = seated.map(p=>p.seat_no)
        const dealerSeat = currentGame.dealer_seat ? nextSeat(prevDealer, seats) : seated[0].seat_no
        const sbSeat = nextSeat(dealerSeat, seats)
        const bbSeat = nextSeat(sbSeat, seats)
        const utgSeat = nextSeat(bbSeat, seats)

        const deck = mkDeck()
        const playersBySession = {}
        for (const p of seated) {
          playersBySession[p.session_id] = {
            session_id: p.session_id,
            username: p.username,
            seat_no: p.seat_no,
            stack: p.stack,
            holeCards: [deck.pop(), deck.pop()],
            folded: false,
            allIn: false,
            currentBet: 0,
            totalCommitted: 0,
            actedStreet: false,
            lastAction: 'dealt',
          }
        }

        const postBlind = (seat, amt, label) => {
          const pl = Object.values(playersBySession).find(x=>x.seat_no===seat)
          const paid = Math.min(pl.stack, amt)
          pl.stack -= paid
          pl.currentBet += paid
          pl.totalCommitted += paid
          pl.lastAction = label
          if (pl.stack === 0) pl.allIn = true
          return paid
        }

        const pot = postBlind(sbSeat, SB, 'small blind') + postBlind(bbSeat, BB, 'big blind')
        const actingSessionId = Object.values(playersBySession).find(x=>x.seat_no===utgSeat)?.session_id || null

        const hand_state = {
          street: 'preflop',
          startedAt: new Date().toISOString(),
          boardCards: [],
          deck,
          pot,
          currentBet: BB,
          minRaise: BB,
          dealerSeat,
          sbSeat,
          bbSeat,
          actingSessionId,
          lastChipMove: { seat: bbSeat, amount: pot, ts: Date.now(), label: 'blinds' },
          playersBySession,
          actionLog: [`Hand #${(currentGame.hand_no||0)+1} started`, `Blinds posted ${SB}/${BB}`],
          winnerSummary: null,
        }

        await supabase.from('game_state').update({ hand_no: (currentGame.hand_no||0)+1, dealer_seat: dealerSeat }).eq('id',1)
        await saveHand(hand_state)
        await refresh()
      }

      function nextActing(state, fromSession) {
        const active = Object.values(state.playersBySession).filter(p => !p.folded && !p.allIn).sort((a,b)=>a.seat_no-b.seat_no)
        if (!active.length) return null
        const currentSeat = state.playersBySession[fromSession]?.seat_no || active[0].seat_no
        const nSeat = nextSeat(currentSeat, active.map(p=>p.seat_no))
        return active.find(p=>p.seat_no===nSeat)?.session_id || active[0].session_id
      }

      function streetResolved(state) {
        const live = Object.values(state.playersBySession).filter(p => !p.folded)
        if (live.length <= 1) return true
        return live.every(p => p.allIn || (p.actedStreet && p.currentBet === state.currentBet))
      }

      function dealNextStreet(state) {
        for (const p of Object.values(state.playersBySession)) {
          p.currentBet = 0
          p.actedStreet = false
        }
        state.currentBet = 0
        state.minRaise = BB

        if (state.street === 'preflop') {
          state.street = 'flop'
          state.boardCards.push(state.deck.pop(), state.deck.pop(), state.deck.pop())
          state.actionLog.push(`Flop: ${prettyCards(state.boardCards)}`)
        } else if (state.street === 'flop') {
          state.street = 'turn'
          state.boardCards.push(state.deck.pop())
          state.actionLog.push(`Turn: ${prettyCards(state.boardCards)}`)
        } else if (state.street === 'turn') {
          state.street = 'river'
          state.boardCards.push(state.deck.pop())
          state.actionLog.push(`River: ${prettyCards(state.boardCards)}`)
        } else {
          state.street = 'showdown'
          state.actionLog.push('Showdown')
        }

        const active = Object.values(state.playersBySession).filter(p=>!p.folded && !p.allIn).sort((a,b)=>a.seat_no-b.seat_no)
        if (!active.length) { state.actingSessionId = null; return }
        const seat = nextSeat(state.dealerSeat, active.map(p=>p.seat_no))
        state.actingSessionId = active.find(p=>p.seat_no===seat)?.session_id || null
      }

      async function finalize(state) {
        const live = Object.values(state.playersBySession).filter(p=>!p.folded)
        const uncontested = live.length === 1
        if (uncontested) {
          live[0].stack += state.pot
          state.winnerSummary = `${live[0].username} wins ${state.pot} (uncontested)`
          state.actionLog.push(state.winnerSummary)
        } else {
          let winners = []
          let best = Infinity
          for (const p of live) {
            const score = bestScore7([...p.holeCards, ...state.boardCards])
            p.showScore = score
            if (score < best) { best = score; winners = [p] }
            else if (score === best) winners.push(p)
          }
          winners.sort((a,b)=>a.seat_no-b.seat_no)
          const base = Math.floor(state.pot / winners.length)
          let rem = state.pot % winners.length
          for (const w of winners) w.stack += base + (rem-- > 0 ? 1 : 0)
          state.winnerSummary = `Winners: ${winners.map(w=>w.username).join(', ')}`
          state.actionLog.push(state.winnerSummary)
        }

        for (const p of Object.values(state.playersBySession)) {
          await supabase.from('lobby_players').update({ stack: p.stack }).eq('session_id', p.session_id)
        }

        state.street = 'waiting'
        state.actingSessionId = null
        await saveHand(state)

        // Auto-start next hand after uncontested win (everyone else folded)
        if (uncontested) {
          setTimeout(async () => {
            try {
              await startHand()
            } catch (_) {
              // no-op
            }
          }, 1000)
        }
      }

      async function act(type) {
        $('actionState').textContent = `‚Äî ‚åõ sending ${type}‚Ä¶`
        await refresh()
        const state = structuredClone(currentHand)
        if (!state?.actingSessionId || state.actingSessionId !== sessionId) {
          $('actionState').textContent = '‚Äî not your turn'
          return
        }
        const me = state.playersBySession[sessionId]
        if (!me || me.folded || me.allIn) {
          $('actionState').textContent = '‚Äî action unavailable'
          return
        }

        const toCall = Math.max(0, state.currentBet - me.currentBet)
        const commit = (n) => {
          const paid = Math.min(n, me.stack)
          me.stack -= paid
          me.currentBet += paid
          me.totalCommitted += paid
          state.pot += paid
          if (me.stack === 0) me.allIn = true
          return paid
        }

        if (type === 'fold') {
          me.folded = true
          me.actedStreet = true
          me.lastAction = 'fold'
          state.actionLog.push(`${me.username}: fold`)
        } else if (type === 'check') {
          if (toCall > 0) return showError('Cannot check; call or fold')
          me.actedStreet = true
          me.lastAction = 'check'
          state.actionLog.push(`${me.username}: check`)
        } else if (type === 'call') {
          commit(toCall)
          me.actedStreet = true
          me.lastAction = `call ${toCall}`
          state.lastChipMove = { seat: me.seat_no, amount: toCall, ts: Date.now(), label: 'call' }
          state.actionLog.push(`${me.username}: call ${toCall}`)
        } else if (type === 'raise') {
          const target = Number($('raiseTo').value || 0)
          if (!(target > state.currentBet)) return showError('Raise-to must be greater than current bet')
          const addAmt = target - me.currentBet
          commit(addAmt)
          state.minRaise = Math.max(state.minRaise, target - state.currentBet)
          state.currentBet = me.currentBet
          me.actedStreet = true
          me.lastAction = `raise to ${me.currentBet}`
          state.lastChipMove = { seat: me.seat_no, amount: addAmt, ts: Date.now(), label: 'raise' }
          state.actionLog.push(`${me.username}: raise to ${me.currentBet}`)
          for (const p of Object.values(state.playersBySession)) if (p.session_id !== me.session_id && !p.folded && !p.allIn) p.actedStreet = false
        } else if (type === 'allin') {
          const shoveAmt = me.stack
          commit(me.stack)
          if (me.currentBet > state.currentBet) {
            state.minRaise = Math.max(state.minRaise, me.currentBet - state.currentBet)
            state.currentBet = me.currentBet
            for (const p of Object.values(state.playersBySession)) if (p.session_id !== me.session_id && !p.folded && !p.allIn) p.actedStreet = false
          }
          me.actedStreet = true
          me.lastAction = 'all-in'
          state.lastChipMove = { seat: me.seat_no, amount: shoveAmt, ts: Date.now(), label: 'all-in' }
          state.actionLog.push(`${me.username}: all-in (${me.currentBet})`)
        }

        const live = Object.values(state.playersBySession).filter(p => !p.folded)
        if (live.length <= 1) {
          await finalize(state)
          return refresh()
        }

        if (streetResolved(state)) {
          dealNextStreet(state)
          if (state.street === 'showdown' || state.street === 'waiting') {
            await finalize(state)
            return refresh()
          }
        } else {
          state.actingSessionId = nextActing(state, sessionId)
        }

        await saveHand(state)
        await refresh()
        $('actionState').textContent = `‚Äî ‚úÖ ${type} sent`
      }

      async function flushTable() {
        const { error } = await supabase.from('game_state').update({
          phase: 'waiting', current_turn_session_id: null, pot: 0, hand_state: {}, updated_at: new Date().toISOString(),
        }).eq('id', 1)
        if (error) return showError(error.message)
        refresh()
      }

      async function clearEntireLobby() {
        if (!confirm('Clear entire lobby and reset table?')) return
        const del = await supabase.from('lobby_players').delete().neq('session_id', '')
        if (del.error) return showError(del.error.message)
        const reset = await supabase.from('game_state').update({
          hand_no: 0, phase: 'waiting', dealer_seat: null, current_turn_session_id: null, pot: 0, hand_state: {}, showdown_state: {}, updated_at: new Date().toISOString(),
        }).eq('id', 1)
        if (reset.error) return showError(reset.error.message)
        refresh()
      }

      $('joinBtn').onclick = join
      $('leaveBtn').onclick = leave
      $('refreshBtn').onclick = refresh
      $('clearLobbyBtn').onclick = clearEntireLobby
      $('foldBtn').onclick = () => act('fold')
      $('checkBtn').onclick = () => act('check')
      $('callBtn').onclick = () => act('call')
      $('raiseBtn').onclick = () => act('raise')
      $('allinBtn').onclick = () => act('allin')

      // Floating join panel toggle
      const joinFloat = document.getElementById('joinFloat')
      const joinDrop  = document.getElementById('joinDrop')
      const joinToggle = document.getElementById('joinToggle')
      joinToggle.addEventListener('click', (e) => {
        e.stopPropagation()
        joinDrop.hidden = !joinDrop.hidden
      })
      document.addEventListener('click', (e) => {
        if (!joinFloat.contains(e.target)) joinDrop.hidden = true
      })

      const channel = supabase
        .channel('cards-static-realtime')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'lobby_players' }, refresh)
        .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state' }, refresh)
        .subscribe()

      refresh()
      setInterval(async () => {
        await supabase.from('lobby_players').update({ heartbeat_at: new Date().toISOString() }).eq('session_id', sessionId)
      }, 15000)
      window.addEventListener('beforeunload', () => supabase.removeChannel(channel))
    </script>
  </body>
</html>
