<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cards ‚Äî Static MVP</title>
    <style>
      :root { color-scheme: dark; font-family: Inter, system-ui, Arial, sans-serif; }
      body { margin: 0; background: #0b0f1a; color: #e8ecf3; }
      .app { max-width: 1000px; margin: 0 auto; padding: 24px; }
      section { margin-top: 16px; background: #141c2d; border: 1px solid #25304a; border-radius: 12px; padding: 14px; }
      .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      input, button { border-radius: 10px; border: 1px solid #314567; background: #0d1320; color: #e8ecf3; padding: 10px 12px; }
      button { cursor: pointer; background: #233050; font-weight: 600; }
      button:hover { background: #2d4169; }
      .error { margin-top: 12px; background: #381a1a; border: 1px solid #6f2d2d; color: #ffd4d4; padding: 10px; border-radius: 8px; }
      .table-shell { background: radial-gradient(circle at center, #1f6b3f 0%, #124a2c 60%, #0c351f 100%); border: 2px solid #8a6a2f; border-radius: 22px; padding: 14px; }
      .board { display: flex; gap: 8px; flex-wrap: wrap; min-height: 44px; align-items: center; }
      .card-pill { display:inline-flex; align-items:center; justify-content:center; min-width:38px; height:46px; border-radius:8px; border:1px solid #5a6b8f; background:#f5f7ff; color:#0a0f1d; font-weight:800; }
      .card-pill.red { color:#b3132c; }
      .seat { background: #0d1320; border: 1px solid #2d3a59; border-radius: 12px; padding: 10px; margin-bottom: 8px; }
      .seat.turn {
        border: 2px solid #ffd84d;
        box-shadow: 0 0 0 2px rgba(255,216,77,0.25) inset, 0 0 18px rgba(255,216,77,0.35);
        animation: breatheGlow 1.6s ease-in-out infinite;
      }
      @keyframes breatheGlow {
        0%, 100% { box-shadow: 0 0 0 2px rgba(255,216,77,0.2) inset, 0 0 10px rgba(255,216,77,0.25); }
        50% { box-shadow: 0 0 0 2px rgba(255,216,77,0.45) inset, 0 0 24px rgba(255,216,77,0.65); }
      }
      .turn-badge { color: #ffdf66; font-weight: 700; margin-left: 8px; }
      .muted { color: #a6b0c2; }
      button:disabled { opacity: 0.45; cursor: not-allowed; }
      .action-bar { display:flex; gap:8px; flex-wrap:wrap; }
      .action-note { font-weight:700; color:#9fc1ff; }
      .chips { display:inline-flex; gap:8px; align-items:center; }
      .chip { background:#1b2740; border:1px solid #3d547f; border-radius:999px; padding:4px 10px; font-size:0.9rem; }
      @media (max-width: 520px) {
        .app { padding: 12px; }
        h1 { font-size: 1.2rem; }
        section { padding: 10px; border-radius: 10px; }
        .row { gap: 8px; }
        input, button { width: 100%; box-sizing: border-box; }
        .action-bar { position: sticky; bottom: 0; background: #10192a; padding: 8px; border:1px solid #2d3a59; border-radius: 10px; }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <h1>Cards ‚Äî Static HTML MVP</h1>
      <p class="muted">Direct GitHub Pages app with full playable hand loop.</p>
      <div id="error" class="error" style="display:none"></div>

      <section>
        <h2>Join</h2>
        <div class="row">
          <input id="username" placeholder="username" maxlength="20" />
          <button id="joinBtn">Join</button>
          <button id="leaveBtn">Leave</button>
          <button id="refreshBtn">Refresh</button>
        </div>
        <p id="whoami" class="muted"></p>
      </section>

      <section>
        <h2>Game Table</h2>
        <div class="row">
          <button id="startBtn">‚ñ∂Ô∏è Start New Hand</button>
          <button id="flushBtn">üßπ Flush Table</button>
          <strong id="stateLine"></strong>
        </div>
        <div class="table-shell" style="margin-top:10px">
          <div class="chips">
            <span class="chip" id="potChip">Pot: 0</span>
            <span class="chip" id="streetChip">Street: waiting</span>
          </div>
          <p style="margin:8px 0 4px"><strong>Board</strong></p>
          <div class="board" id="board"></div>
        </div>
      </section>

      <section>
        <h2>Your Hand & Actions</h2>
        <div class="board" id="myHand"></div>
        <div class="row">
          <span id="toCall">To call: 0</span>
          <span id="myStack">Stack: -</span>
          <strong id="actionState" class="action-note">Status: waiting</strong>
        </div>
        <div class="action-bar" style="margin-top:10px">
          <button id="foldBtn">‚ùå Fold</button>
          <button id="checkBtn">‚úÖ Check</button>
          <button id="callBtn">üìû Call</button>
          <input id="raiseTo" type="number" placeholder="Raise to" style="width:110px" />
          <button id="raiseBtn">‚¨ÜÔ∏è Raise</button>
          <button id="allinBtn">üî• All-in</button>
        </div>
      </section>

      <section>
        <h2>Seats</h2>
        <div id="seats"></div>
      </section>

      <section>
        <h2>Hand Log</h2>
        <ul id="log"></ul>
      </section>

      <section>
        <h2>Options</h2>
        <div class="row">
          <button id="clearLobbyBtn">Clear Entire Lobby</button>
        </div>
      </section>
    </main>

    <script type="module">
      import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
      import PokerHand from 'https://esm.sh/poker-hand-evaluator@1.0.1'

      const SUPABASE_URL = 'https://oiltjegxfwjdvuzbsyfv.supabase.co'
      const SUPABASE_ANON_KEY = 'sb_publishable_7rNCoUWbz3FnDY4VdIvCbg_9R-LuirL'
      const SB = 1
      const BB = 2

      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      const sessionKey = 'cards_session_id'
      let sessionId = localStorage.getItem(sessionKey)
      if (!sessionId) {
        sessionId = crypto.randomUUID()
        localStorage.setItem(sessionKey, sessionId)
      }

      let currentPlayers = []
      let currentGame = {}
      let currentHand = {}

      const $ = (id) => document.getElementById(id)
      const showError = (msg) => {
        const el = $('error')
        el.style.display = msg ? 'block' : 'none'
        el.textContent = msg || ''
      }

      const shuffle = (arr) => {
        const a = [...arr]
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]
        }
        return a
      }
      const mkDeck = () => shuffle('23456789TJQKA'.split('').flatMap(r => 'CDHS'.split('').map(s => r+s)))
      const SUIT_EMOJI = { C: '‚ô£Ô∏è', D: '‚ô¶Ô∏è', H: '‚ô•Ô∏è', S: '‚ô†Ô∏è' }
      const prettyCard = (c) => {
        if (!c || typeof c !== 'string' || c.length < 2) return c || '-'
        const rank = c[0]
        const suit = c[1].toUpperCase()
        return `${rank}${SUIT_EMOJI[suit] || suit}`
      }
      const prettyCards = (cards) => (cards || []).map(prettyCard).join(' ')
      const cardHtml = (c) => {
        const p = prettyCard(c)
        const isRed = p.includes('‚ô¶Ô∏è') || p.includes('‚ô•Ô∏è')
        return `<span class="card-pill ${isRed ? 'red' : ''}">${p}</span>`
      }
      const cardsHtml = (cards, faceDown = false, count = 2) => {
        if (faceDown) return Array.from({ length: count }).map(() => '<span class="card-pill">üÇ†</span>').join(' ')
        if (!cards || !cards.length) return '<span class="muted">-</span>'
        return cards.map(cardHtml).join(' ')
      }

      const nextSeat = (from, seats) => {
        const sorted = [...seats].sort((a,b)=>a-b)
        for (const s of sorted) if (s > from) return s
        return sorted[0]
      }

      const combos = (arr, k) => {
        const out = []
        const pick = (start, acc) => {
          if (acc.length === k) return out.push(acc)
          for (let i = start; i < arr.length; i++) pick(i + 1, [...acc, arr[i]])
        }
        pick(0, [])
        return out
      }

      const bestScore7 = (cards7) => {
        let best = Infinity
        for (const c of combos(cards7, 5)) {
          const h = new PokerHand(c.join(' '))
          best = Math.min(best, h.getScore())
        }
        return best
      }

      const getMe = () => currentPlayers.find(p => p.session_id === sessionId)
      const getMyHandPlayer = () => currentHand.playersBySession?.[sessionId]

      async function saveHand(state) {
        const { error } = await supabase.from('game_state').update({
          phase: state.street || 'waiting',
          current_turn_session_id: state.actingSessionId || null,
          pot: state.pot || 0,
          hand_state: state,
          updated_at: new Date().toISOString(),
          last_action_at: new Date().toISOString(),
        }).eq('id', 1)
        if (error) throw error
      }

      function render() {
        const me = getMe()
        const hand = currentHand || {}
        const meHp = getMyHandPlayer()

        $('whoami').textContent = me ? `Joined as ${me.username} (seat ${me.seat_no})` : `Not joined (session ${sessionId.slice(0,8)}...)`
        const street = hand.street || 'waiting'
        const pot = hand.pot || currentGame.pot || 0
        $('stateLine').textContent = `Hand #${currentGame.hand_no || 0}`
        $('potChip').textContent = `Pot: ${pot}`
        $('streetChip').textContent = `Street: ${street}`
        $('board').innerHTML = cardsHtml(hand.boardCards)
        $('myHand').innerHTML = meHp?.holeCards?.length ? cardsHtml(meHp.holeCards) : '<span class="muted">No cards (join + start hand)</span>'

        const toCall = meHp ? Math.max(0, (hand.currentBet || 0) - (meHp.currentBet || 0)) : 0
        $('toCall').textContent = `To call: ${toCall}`
        $('myStack').textContent = `Stack: ${meHp?.stack ?? me?.stack ?? '-'}`

        const myTurn = hand.actingSessionId && hand.actingSessionId === sessionId
        $('actionState').textContent = myTurn ? 'Status: üü° Your turn' : 'Status: ‚è≥ Waiting'
        $('foldBtn').disabled = !myTurn
        $('checkBtn').disabled = !myTurn || toCall > 0
        $('callBtn').disabled = !myTurn || toCall === 0
        $('raiseBtn').disabled = !myTurn
        $('allinBtn').disabled = !myTurn

        $('seats').innerHTML = currentPlayers
          .filter(p => p.seat_no != null)
          .sort((a,b)=>a.seat_no-b.seat_no)
          .map(p => {
            const hp = hand.playersBySession?.[p.session_id]
            const isTurn = hand.actingSessionId && hand.actingSessionId === p.session_id
            const holeHtml = (p.session_id === sessionId || hand.street === 'waiting')
              ? cardsHtml(hp?.holeCards || [])
              : cardsHtml([], true, 2)
            return `<div class="seat ${isTurn ? 'turn' : ''}"><strong>Seat ${p.seat_no}: ${p.username}</strong>${isTurn ? '<span class="turn-badge">‚óÄ TURN</span>' : ''}<br/>Stack: ${hp?.stack ?? p.stack} ‚Ä¢ Hole: ${holeHtml} ‚Ä¢ Bet: ${hp?.currentBet ?? 0} ‚Ä¢ Last: ${hp?.lastAction || '-'}</div>`
          }).join('')

        const log = hand.actionLog || []
        $('log').innerHTML = log.length ? log.slice(-16).map(x => `<li>${x}</li>`).join('') : '<li class="muted">No actions yet.</li>'
      }

      async function refresh() {
        showError('')
        const [pRes, gRes] = await Promise.all([
          supabase.from('lobby_players').select('*').order('seat_no', { ascending: true }),
          supabase.from('game_state').select('*').eq('id', 1).single(),
        ])
        if (pRes.error) return showError(pRes.error.message)
        if (gRes.error) return showError(gRes.error.message)

        currentPlayers = pRes.data || []
        currentGame = gRes.data || {}
        currentHand = currentGame.hand_state || {}
        render()
      }

      async function join() {
        const username = $('username').value.trim()
        if (!username) return showError('Username required')
        const { data } = await supabase.from('lobby_players').select('seat_no')
        const used = new Set((data||[]).map(p=>p.seat_no).filter(Boolean))
        let seat = null
        for (let i=1;i<=8;i++) if (!used.has(i)) { seat = i; break }
        if (!seat) return showError('Lobby full')

        const { error } = await supabase.from('lobby_players').upsert({
          session_id: sessionId,
          username,
          seat_no: seat,
          heartbeat_at: new Date().toISOString(),
        }, { onConflict: 'session_id' })
        if (error) return showError(error.message)
        refresh()
      }

      async function leave() {
        await supabase.from('lobby_players').delete().eq('session_id', sessionId)
        refresh()
      }

      async function startHand() {
        await refresh()
        const seated = currentPlayers.filter(p => p.seat_no != null).sort((a,b)=>a.seat_no-b.seat_no)
        if (seated.length < 2) return showError('Need at least 2 players')

        const prevDealer = currentGame.dealer_seat || seated[0].seat_no
        const seats = seated.map(p=>p.seat_no)
        const dealerSeat = currentGame.dealer_seat ? nextSeat(prevDealer, seats) : seated[0].seat_no
        const sbSeat = nextSeat(dealerSeat, seats)
        const bbSeat = nextSeat(sbSeat, seats)
        const utgSeat = nextSeat(bbSeat, seats)

        const deck = mkDeck()
        const playersBySession = {}
        for (const p of seated) {
          playersBySession[p.session_id] = {
            session_id: p.session_id,
            username: p.username,
            seat_no: p.seat_no,
            stack: p.stack,
            holeCards: [deck.pop(), deck.pop()],
            folded: false,
            allIn: false,
            currentBet: 0,
            totalCommitted: 0,
            actedStreet: false,
            lastAction: 'dealt',
          }
        }

        const postBlind = (seat, amt, label) => {
          const pl = Object.values(playersBySession).find(x=>x.seat_no===seat)
          const paid = Math.min(pl.stack, amt)
          pl.stack -= paid
          pl.currentBet += paid
          pl.totalCommitted += paid
          pl.lastAction = label
          if (pl.stack === 0) pl.allIn = true
          return paid
        }

        const pot = postBlind(sbSeat, SB, 'small blind') + postBlind(bbSeat, BB, 'big blind')
        const actingSessionId = Object.values(playersBySession).find(x=>x.seat_no===utgSeat)?.session_id || null

        const hand_state = {
          street: 'preflop',
          boardCards: [],
          deck,
          pot,
          currentBet: BB,
          minRaise: BB,
          dealerSeat,
          actingSessionId,
          playersBySession,
          actionLog: [`Hand #${(currentGame.hand_no||0)+1} started`, `Blinds posted ${SB}/${BB}`],
          winnerSummary: null,
        }

        await supabase.from('game_state').update({ hand_no: (currentGame.hand_no||0)+1, dealer_seat: dealerSeat }).eq('id',1)
        await saveHand(hand_state)
        await refresh()
      }

      function nextActing(state, fromSession) {
        const active = Object.values(state.playersBySession).filter(p => !p.folded && !p.allIn).sort((a,b)=>a.seat_no-b.seat_no)
        if (!active.length) return null
        const currentSeat = state.playersBySession[fromSession]?.seat_no || active[0].seat_no
        const nSeat = nextSeat(currentSeat, active.map(p=>p.seat_no))
        return active.find(p=>p.seat_no===nSeat)?.session_id || active[0].session_id
      }

      function streetResolved(state) {
        const live = Object.values(state.playersBySession).filter(p => !p.folded)
        if (live.length <= 1) return true
        return live.every(p => p.allIn || (p.actedStreet && p.currentBet === state.currentBet))
      }

      function dealNextStreet(state) {
        for (const p of Object.values(state.playersBySession)) {
          p.currentBet = 0
          p.actedStreet = false
        }
        state.currentBet = 0
        state.minRaise = BB

        if (state.street === 'preflop') {
          state.street = 'flop'
          state.boardCards.push(state.deck.pop(), state.deck.pop(), state.deck.pop())
          state.actionLog.push(`Flop: ${prettyCards(state.boardCards)}`)
        } else if (state.street === 'flop') {
          state.street = 'turn'
          state.boardCards.push(state.deck.pop())
          state.actionLog.push(`Turn: ${prettyCards(state.boardCards)}`)
        } else if (state.street === 'turn') {
          state.street = 'river'
          state.boardCards.push(state.deck.pop())
          state.actionLog.push(`River: ${prettyCards(state.boardCards)}`)
        } else {
          state.street = 'showdown'
          state.actionLog.push('Showdown')
        }

        const active = Object.values(state.playersBySession).filter(p=>!p.folded && !p.allIn).sort((a,b)=>a.seat_no-b.seat_no)
        if (!active.length) { state.actingSessionId = null; return }
        const seat = nextSeat(state.dealerSeat, active.map(p=>p.seat_no))
        state.actingSessionId = active.find(p=>p.seat_no===seat)?.session_id || null
      }

      async function finalize(state) {
        const live = Object.values(state.playersBySession).filter(p=>!p.folded)
        const uncontested = live.length === 1
        if (uncontested) {
          live[0].stack += state.pot
          state.winnerSummary = `${live[0].username} wins ${state.pot} (uncontested)`
          state.actionLog.push(state.winnerSummary)
        } else {
          let winners = []
          let best = Infinity
          for (const p of live) {
            const score = bestScore7([...p.holeCards, ...state.boardCards])
            p.showScore = score
            if (score < best) { best = score; winners = [p] }
            else if (score === best) winners.push(p)
          }
          winners.sort((a,b)=>a.seat_no-b.seat_no)
          const base = Math.floor(state.pot / winners.length)
          let rem = state.pot % winners.length
          for (const w of winners) w.stack += base + (rem-- > 0 ? 1 : 0)
          state.winnerSummary = `Winners: ${winners.map(w=>w.username).join(', ')}`
          state.actionLog.push(state.winnerSummary)
        }

        for (const p of Object.values(state.playersBySession)) {
          await supabase.from('lobby_players').update({ stack: p.stack }).eq('session_id', p.session_id)
        }

        state.street = 'waiting'
        state.actingSessionId = null
        await saveHand(state)

        // Auto-start next hand after uncontested win (everyone else folded)
        if (uncontested) {
          setTimeout(async () => {
            try {
              await startHand()
            } catch (_) {
              // no-op
            }
          }, 1000)
        }
      }

      async function act(type) {
        $('actionState').textContent = `Status: ‚åõ Sending ${type}...`
        await refresh()
        const state = structuredClone(currentHand)
        if (!state?.actingSessionId || state.actingSessionId !== sessionId) {
          $('actionState').textContent = 'Status: not your turn'
          return
        }
        const me = state.playersBySession[sessionId]
        if (!me || me.folded || me.allIn) {
          $('actionState').textContent = 'Status: action unavailable'
          return
        }

        const toCall = Math.max(0, state.currentBet - me.currentBet)
        const commit = (n) => {
          const paid = Math.min(n, me.stack)
          me.stack -= paid
          me.currentBet += paid
          me.totalCommitted += paid
          state.pot += paid
          if (me.stack === 0) me.allIn = true
          return paid
        }

        if (type === 'fold') {
          me.folded = true
          me.actedStreet = true
          me.lastAction = 'fold'
          state.actionLog.push(`${me.username}: fold`)
        } else if (type === 'check') {
          if (toCall > 0) return showError('Cannot check; call or fold')
          me.actedStreet = true
          me.lastAction = 'check'
          state.actionLog.push(`${me.username}: check`)
        } else if (type === 'call') {
          commit(toCall)
          me.actedStreet = true
          me.lastAction = `call ${toCall}`
          state.actionLog.push(`${me.username}: call ${toCall}`)
        } else if (type === 'raise') {
          const target = Number($('raiseTo').value || 0)
          if (!(target > state.currentBet)) return showError('Raise-to must be greater than current bet')
          commit(target - me.currentBet)
          state.minRaise = Math.max(state.minRaise, target - state.currentBet)
          state.currentBet = me.currentBet
          me.actedStreet = true
          me.lastAction = `raise to ${me.currentBet}`
          state.actionLog.push(`${me.username}: raise to ${me.currentBet}`)
          for (const p of Object.values(state.playersBySession)) if (p.session_id !== me.session_id && !p.folded && !p.allIn) p.actedStreet = false
        } else if (type === 'allin') {
          commit(me.stack)
          if (me.currentBet > state.currentBet) {
            state.minRaise = Math.max(state.minRaise, me.currentBet - state.currentBet)
            state.currentBet = me.currentBet
            for (const p of Object.values(state.playersBySession)) if (p.session_id !== me.session_id && !p.folded && !p.allIn) p.actedStreet = false
          }
          me.actedStreet = true
          me.lastAction = 'all-in'
          state.actionLog.push(`${me.username}: all-in (${me.currentBet})`)
        }

        const live = Object.values(state.playersBySession).filter(p => !p.folded)
        if (live.length <= 1) {
          await finalize(state)
          return refresh()
        }

        if (streetResolved(state)) {
          dealNextStreet(state)
          if (state.street === 'showdown' || state.street === 'waiting') {
            await finalize(state)
            return refresh()
          }
        } else {
          state.actingSessionId = nextActing(state, sessionId)
        }

        await saveHand(state)
        await refresh()
        $('actionState').textContent = `Status: ‚úÖ ${type} sent`
      }

      async function flushTable() {
        const { error } = await supabase.from('game_state').update({
          phase: 'waiting', current_turn_session_id: null, pot: 0, hand_state: {}, updated_at: new Date().toISOString(),
        }).eq('id', 1)
        if (error) return showError(error.message)
        refresh()
      }

      async function clearEntireLobby() {
        if (!confirm('Clear entire lobby and reset table?')) return
        const del = await supabase.from('lobby_players').delete().neq('session_id', '')
        if (del.error) return showError(del.error.message)
        const reset = await supabase.from('game_state').update({
          hand_no: 0, phase: 'waiting', dealer_seat: null, current_turn_session_id: null, pot: 0, hand_state: {}, showdown_state: {}, updated_at: new Date().toISOString(),
        }).eq('id', 1)
        if (reset.error) return showError(reset.error.message)
        refresh()
      }

      $('joinBtn').onclick = join
      $('leaveBtn').onclick = leave
      $('refreshBtn').onclick = refresh
      $('startBtn').onclick = startHand
      $('flushBtn').onclick = flushTable
      $('clearLobbyBtn').onclick = clearEntireLobby
      $('foldBtn').onclick = () => act('fold')
      $('checkBtn').onclick = () => act('check')
      $('callBtn').onclick = () => act('call')
      $('raiseBtn').onclick = () => act('raise')
      $('allinBtn').onclick = () => act('allin')

      const channel = supabase
        .channel('cards-static-realtime')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'lobby_players' }, refresh)
        .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state' }, refresh)
        .subscribe()

      refresh()
      setInterval(async () => {
        await supabase.from('lobby_players').update({ heartbeat_at: new Date().toISOString() }).eq('session_id', sessionId)
      }, 15000)
      window.addEventListener('beforeunload', () => supabase.removeChannel(channel))
    </script>
  </body>
</html>
